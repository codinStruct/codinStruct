<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Background</title>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"
      integrity="sha512-N4kV7GkNv7QR7RX9YF/olywyIgIwNvfEe2nZtfyj73HdjCUkAfOBDbcuJ/cTaN04JKRnw1YG1wnUyNKMsNgg3g=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script>
      // Adapted from a sketch from by yasai: https://openprocessing.org/sketch/494102

      var particles_a = [];
      var particles_b = [];
      var particles_c = [];
      var nums = 0;

      // Left-closed interval of possible particle speeds
      var speedLimits = [0.1, 1.5];
      // Left-closed interval of possible stroke weights
      var strokeWeightLimits = [1, 3];
      var noiseScale = 400;

      var backgroundColor;
      var particleColors = [];

      function windowResized() {
        setup();
      }

      function setup() {
        // The number of points is proportional to the area
        nums = Math.round((windowWidth * windowHeight) / 8000);
        // The radius of the particle spawn circles
        let spawnRadius = min(windowWidth, windowHeight) / 3;

        backgroundColor = color("#191724");
        particleColors = [
          color("#6b4f8f1f"),
          color("#9d7ec21f"),
          color(random(255.1), random(255.1), random(255.1)),
        ];

        createCanvas(windowWidth, windowHeight);

        background(backgroundColor);

        // Spawn particles in random position in one of two half circles
        for (let p_arr of [particles_a, particles_b, particles_c]) {
          for (var i = 0; i < nums; i++) {
            let r = spawnRadius * sqrt(random());
            let theta = map(random(), 0, 1, 0, PI);

            // true (1) means the particle will spawn in the left circle
            let left = i % 2;

            p_arr[i] = new Particle(
              left * windowWidth +
                r * cos((theta += left ? HALF_PI : -HALF_PI)),
              windowHeight / 2 + r * sin(theta)
            );
          }
        }
      }

      function draw() {
        smooth();
        for (let [p_arr_i, p_arr] of [
          particles_a,
          particles_b,
          particles_c,
        ].entries()) {
          for (var i = p_arr.length - 1; i >= 0; i--) {
            p_arr[i].move();
            // Remove particle if outside viewport
            if (p_arr[i].checkEdge()) {
              p_arr.splice(i, 1);
              break;
            }

            // Stroke weight based on particle position
            strokeWeight(
              map(
                noise(p_arr[i].pos.x / noiseScale, p_arr[i].pos.y / noiseScale),
                0,
                1,
                // ! Inverting the range inverts the result, probably dangerous
                strokeWeightLimits[1],
                strokeWeightLimits[0]
              )
            );
            stroke(particleColors[p_arr_i]);

            p_arr[i].display();
          }
        }
      }

      function Particle(x, y) {
        this.dir = createVector(0, 0);
        this.vel = createVector(0, 0);
        this.pos = createVector(x, y);
        this.last_pos = this.pos;
        this.angle =
          noise(this.pos.x / noiseScale, this.pos.y / noiseScale) *
          TWO_PI *
          noiseScale;

        this.move = function () {
          // Speed based on position
          this.speed = map(
            noise(this.pos.x / noiseScale, this.pos.y / noiseScale),
            0.3,
            0.7,
            speedLimits[0],
            speedLimits[1]
          );

          var newAngle =
            noise(this.pos.x / noiseScale, this.pos.y / noiseScale) *
            TWO_PI *
            noiseScale;

          this.last_pos = this.pos;

          // This makes the movement more smooth
          this.angle = (this.angle + newAngle) / 2;

          this.dir.x = cos(this.angle / 2);
          this.dir.y = sin(this.angle / 2);
          this.vel = this.dir.copy();

          this.vel.mult(this.speed);
          this.pos.add(this.vel);
        };

        this.checkEdge = function () {
          return (
            this.pos.x > width + 100 ||
            this.pos.x < -100 ||
            this.pos.y > height + 100 ||
            this.pos.y < -100
          );
        };

        this.display = function () {
          line(this.pos.x, this.pos.y, this.last_pos.x, this.last_pos.y);
        };
      }
    </script>
    <style>
      * {
        margin: 0px;
        overflow: hidden;
      }
    </style>
  </head>
  <body></body>
</html>
