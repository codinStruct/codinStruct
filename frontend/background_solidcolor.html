<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Background</title>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"
      integrity="sha512-N4kV7GkNv7QR7RX9YF/olywyIgIwNvfEe2nZtfyj73HdjCUkAfOBDbcuJ/cTaN04JKRnw1YG1wnUyNKMsNgg3g=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script>
      // Blend two colors using the function "over" with straight alpha (https://en.wikipedia.org/wiki/Alpha_compositing#Description)
      function colorBlendOver(bg, fg) {
        let r = [red(fg), red(bg)];
        let g = [green(fg), green(bg)];
        let b = [blue(fg), blue(bg)];
        let a = [alpha(fg) / 255, alpha(bg) / 255];

        return color(
          r[0] * a[0] + r[1] * a[1] * (1 - a[0]),
          g[0] * a[0] + g[1] * a[1] * (1 - a[0]),
          b[0] * a[0] + b[1] * a[1] * (1 - a[0])
        );
      }

      // Adapted from a sketch from by yasai: https://openprocessing.org/sketch/494102

      var particles_a = [];
      var particles_b = [];
      var particles_c = [];
      var nums = 0;
      // Left-closed interval of possible particle speeds
      var speedLimits = [0.05, 0.4];
      // Left-closed interval of possible stroke weights
      var strokeWeightLimits = [0.05, 2];
      var noiseScale = 400;

      var backgroundColor;
      var particleColors = [];

      function windowResized() {
        setup();
      }

      function setup() {
        // The number of points is proportional to the area
        nums = Math.round((windowWidth * windowHeight) / 2000);

        // Colors used in the site with some alpha
        backgroundColor = color("#191724");
        particleColors = [
          // Convert the colors to full alpha by blending with the background
          // So drawing on the same spot multiple times will not distort the color
          colorBlendOver(backgroundColor, color("#6b4f8f68")),
          colorBlendOver(backgroundColor, color("#9d7ec268")),
          colorBlendOver(backgroundColor, color("#c9d1d968")),
        ];

        createCanvas(windowWidth, windowHeight);

        background(backgroundColor);

        // Particles have a 100px area to go outside the viewing area for better edges
        for (var i = 0; i < nums; i++) {
          particles_a[i] = new Particle(
            random(-100, width + 100),
            random(-100, height + 100)
          );
          particles_b[i] = new Particle(
            random(-100, width + 100),
            random(-100, height + 100)
          );
          particles_c[i] = new Particle(
            random(-100, width + 100),
            random(-100, height + 100)
          );
        }
      }

      function draw() {
        smooth();
        for (var i = 0; i < nums; i++) {
          strokeWeight(particles_a[i].getStrokeWeight());
          stroke(particleColors[0]);
          particles_a[i].move();
          particles_a[i].display();
          particles_a[i].checkEdge();

          strokeWeight(particles_b[i].getStrokeWeight());
          stroke(particleColors[1]);
          particles_b[i].move();
          particles_b[i].display();
          particles_b[i].checkEdge();

          strokeWeight(particles_c[i].getStrokeWeight());
          stroke(particleColors[2]);
          particles_c[i].move();
          particles_c[i].display();
          particles_c[i].checkEdge();
        }
      }

      function Particle(x, y) {
        this.dir = createVector(0, 0);
        this.vel = createVector(0, 0);
        this.pos = createVector(x, y);
        this.last_pos = this.pos;
        this.angle =
          noise(this.pos.x / noiseScale, this.pos.y / noiseScale) *
          TWO_PI *
          noiseScale;

        this.move = function () {
          // Speed based on position
          this.speed = map(
            noise(this.pos.x / noiseScale, this.pos.y / noiseScale),
            0.3,
            0.7,
            speedLimits[0],
            speedLimits[1]
          );

          var newAngle =
            noise(this.pos.x / noiseScale, this.pos.y / noiseScale) *
            TWO_PI *
            noiseScale;

          this.last_pos = this.pos;

          // This makes the movement more smooth
          this.angle = (this.angle + newAngle) / 2;

          this.dir.x = cos(this.angle);
          this.dir.y = sin(this.angle);
          this.vel = this.dir.copy();

          this.vel.mult(this.speed);
          this.pos.add(this.vel);
        };

        this.checkEdge = function () {
          if (
            this.pos.x > width + 100 ||
            this.pos.x < -100 ||
            this.pos.y > height + 100 ||
            this.pos.y < -100
          ) {
            this.pos.x = random(100, width);
            this.pos.y = random(100, height);
          }
        };

        this.display = function () {
          line(this.pos.x, this.pos.y, this.last_pos.x, this.last_pos.y);
        };

        // Stroke weight based on particle position
        this.getStrokeWeight = function () {
          return map(
            this.speed,
            speedLimits[0],
            speedLimits[1],
            // ! Inverting the range inverts the result, probably dangerous
            strokeWeightLimits[1],
            strokeWeightLimits[0]
          );
        };
      }
    </script>
    <style>
      * {
        margin: 0px;
        overflow: hidden;
      }
    </style>
  </head>
  <body></body>
</html>
